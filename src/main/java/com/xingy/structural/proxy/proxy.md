https://www.runoob.com/design-pattern/proxy-pattern.html

http://c.biancheng.net/view/1359.html

代理模式的结构与实现
代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。
1. 模式的结构
代理模式的主要角色如下。
抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。


代理模式的应用场景
前面分析了代理模式的结构与特点，现在来分析以下的应用场景。
远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。

代理模式与装饰者模式的区别
UML类图基本没区别，都是实现同一个接口，一个类包装另一 个类。 两者的定义：

装饰器模式：能动态的新增或组合对象的行为 
在不改变接口的前提下，动态扩展对象的功能。关于装饰者模式的，可以参考我的这一篇博客 装饰者模式及其应用

代理模式：为其他对象提供一种代理以控制对这个对象的访问 
在不改变接口的前提下，控制对象的访问

装饰模式是“新增行为”，而代理模式是“控制访问”。关键就是我们如何判断是“新增行 为”还是“控制访问”。你在一个地方写装饰，大家就知道这是在增加功能，你写代理，大家就知道是在限制。
